<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Треск и скрежет в моей голове]]></title>
  <link href="http://blog.alfss.net//blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.alfss.net//"/>
  <updated>2012-11-06T03:35:20+04:00</updated>
  <id>http://blog.alfss.net//</id>
  <author>
    <name><![CDATA[Sergey V. Kravchuk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Установка PIL в virtualenv (Ubuntu 12.04 LTS x64)]]></title>
    <link href="http://blog.alfss.net//post/2012/10/26/ustanovka-pil-v-virtualenv-ubuntu-12-dot-04-lts-x64/"/>
    <updated>2012-10-26T22:12:00+04:00</updated>
    <id>http://blog.alfss.net//post/2012/10/26/ustanovka-pil-v-virtualenv-ubuntu-12-dot-04-lts-x64</id>
    <content type="html"><![CDATA[<p>У PIL есть проблема с поисками бибблиотек на 64х битных системах.
Простой хак для решения данной проблемы на ubuntu 12.04 LTS x 64</p>

<p>{% codeblock %}
ln -snf /usr/lib/x86_64-linux-gnu/libfreetype.so /usr/lib
ln -snf /usr/lib/x86_64-linux-gnu/libz.so /usr/lib
ln -snf /usr/lib/x86_64-linux-gnu/libjpeg.so /usr/lib
{% endcodeblock %}</p>

<p>После этого можно спокойно ставить PIL в virtualenv.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Установка redmine (Ubuntu 12.04 LTS)]]></title>
    <link href="http://blog.alfss.net//post/2012/10/26/ustanovka-redmine-ubuntu-12-dot-04-lts/"/>
    <updated>2012-10-26T22:10:00+04:00</updated>
    <id>http://blog.alfss.net//post/2012/10/26/ustanovka-redmine-ubuntu-12-dot-04-lts</id>
    <content type="html"><![CDATA[<p>Я считаю что ставить rails приложения лучше всего через RVM.
Ниже описаны действия для развертывания redmine на только что установленной системе.</p>

<h3>Подготавливаем окружение</h3>

<p>Устанавливаем необходимые пакеты.
{% codeblock %}
sudo apt-get install imagemagick build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion pkg-config libpq-dev build-essential bison openssl libreadline5 libreadline-dev curl git-core zlib1g zlib1g-dev libssl-dev vim libsqlite3-0 libsqlite3-dev sqlite3 libreadline-dev libxml2-dev git-core subversion autoconf curl git-core  libmagickcore-dev libmagickwand-dev
{% endcodeblock %}</p>

<!--more-->


<p>Создаем пользователя для запуска приложения.
{% codeblock %}
sudo useradd -u 2001 -m -s/bin/bash rails
passwd rails
{% endcodeblock %}</p>

<p>Устанавливаем rvm.
{% codeblock %}
ssh rails@localhost
echo insecure >> ~/.curlrc
bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer )
rvm install 1.9.2-head
exit
{% endcodeblock %}</p>

<h3>Устанавливаем redmine</h3>

<p>Я предпочитаю хранить все rails приложения в директории /spool/rails.
{% codeblock %}
sudo mkdir  -p /spool/rails
cd /spool/rails
sudo svn co http://redmine.rubyforge.org/svn/branches/2.0-stable redmine-2.0
sudo chown -R rails:rails  /spool/rails/redmine-2.0
{% endcodeblock %}</p>

<p>{% codeblock %}
ssh rails@localhost
cd /spool/rails/redmine-2.0
bundle install --without development test
mkdir -p /spool/rails/redmine-2.0/tmp/pids/
exit
{% endcodeblock %}</p>

<h3>Настраиваем redmine и unicorn</h3>

<p>Настройка redmine в самом простом случае сводится к прописыванию доступов к БД.
Unicorn будте использоватся как сервер приложений.</p>

<p>Конфиг unicorn (/spool/rails/redmine-2.0/config/unicorn.rb)
{% codeblock %}
worker_processes 1
listen "127.0.0.1:8081", :tcp_nopush => true
timeout 90
pid "/spool/rails/redmine-2.0/tmp/pids/unicorn.pid"
working_directory "/spool/rails/redmine-2.0"
{% endcodeblock %}</p>

<p>Прописываем доступы к БД (/spool/rails/redmine-2.0/config/database.yml)
{% codeblock %}
production:
  adapter: postgresql
  database: redmine
  host: db.server.ru
  username: redmine
  password: "password"
{% endcodeblock %}</p>

<p>Стартовый скрипт unicorn /etc/init.d/unicorn_redmine
{% codeblock lang:bash %}</p>

<h1>!/bin/bash</h1>

<h3>BEGIN INIT INFO</h3>

<h1>Provides:          redmine</h1>

<h1>Required-Start:    $all</h1>

<h1>Required-Stop:     $network $local_fs $syslog</h1>

<h1>Default-Start:     2 3 4 5</h1>

<h1>Default-Stop:      0 1 6</h1>

<h1>Short-Description: Start the APPLICATION unicorns at boot</h1>

<h1>Description:       Enable APPLICATION at boot time.</h1>

<h3>END INIT INFO</h3>

<h1></h1>

<h1>Use this as a basis for your own Unicorn init script.</h1>

<h1>Change APPLICATION to match your app.</h1>

<h1>Make sure that all paths are correct.</h1>

<p>set -u
set -e</p>

<h1>Change these to match your app:</h1>

<p>APP_NAME="redmine"
APP_ROOT="/spool/rails/redmine-2.0"
PID="/spool/rails/redmine-2.0/tmp/pids/unicorn.pid"
ENV=production</p>

<p>GEM_HOME="/home/rails/.rvm/gems/ruby-1.9.2-head"</p>

<p>UNICORN_OPTS="-D -E $ENV -c $APP_ROOT/config/unicorn.rb"</p>

<p>SET_PATH="cd $APP_ROOT; rvm use 1.9.2-head; export GEM_HOME=$GEM_HOME"
CMD="$SET_PATH; /home/rails/.rvm/bin/rvm-shell 'default' -c 'bundle exec unicorn $UNICORN_OPTS'"</p>

<p>old_pid="$PID.oldbin"</p>

<p>cd $APP_ROOT || exit 1</p>

<p>sig () {</p>

<pre><code>test -s "$PID" &amp;&amp; kill -$1 `cat $PID`
</code></pre>

<p>}</p>

<p>oldsig () {</p>

<pre><code>test -s $old_pid &amp;&amp; kill -$1 `cat $old_pid`
</code></pre>

<p>}</p>

<p>case ${1-help} in
start)</p>

<pre><code>sig 0 &amp;&amp; echo &gt;&amp;2 "Already running" &amp;&amp; exit 0
su - rails -c "$CMD"
;;
</code></pre>

<p>stop)</p>

<pre><code>sig QUIT &amp;&amp; exit 0
echo &gt;&amp;2 "Not running"
;;
</code></pre>

<p>force-stop)</p>

<pre><code>sig TERM &amp;&amp; exit 0
echo &gt;&amp;2 "Not running"
;;
</code></pre>

<p>restart|reload)</p>

<pre><code>sig HUP &amp;&amp; echo reloaded OK &amp;&amp; exit 0
echo &gt;&amp;2 "Couldn't reload, starting '$CMD' instead"
su - rails -c "$CMD"
;;
</code></pre>

<p>upgrade)</p>

<pre><code>sig USR2 &amp;&amp; exit 0
echo &gt;&amp;2 "Couldn't upgrade, starting '$CMD' instead"
su - rails -c "$CMD"
;;
</code></pre>

<p>rotate)</p>

<pre><code>sig USR1 &amp;&amp; echo rotated logs OK &amp;&amp; exit 0
echo &gt;&amp;2 "Couldn't rotate logs" &amp;&amp; exit 1
;;
</code></pre>

<p>*)</p>

<pre><code>echo &gt;&amp;2 "Usage: $0 &lt;start|stop|restart|upgrade|rotate|force-stop&gt;"
exit 1
;;
</code></pre>

<p>esac
{% endcodeblock %}</p>

<h3>Инициализируем session, БД и вносим в авто-старт</h3>

<p>Генерируем ключ для session и БД.
{% codeblock %}
ssh rails@localhost
cd /spool/rails/redmine-2.0
rake generate_secret_token
RAILS_ENV=production rake db:migrate
exit
{% endcodeblock %}</p>

<p>Добавляем в автостарт unicorn и запускаем.
{% codeblock %}
sudo update-rc.d unicorn_redmine defaults
sudo /etc/init.d/unicorn_redmine start
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenVPN + аутентификация по логину и паролю]]></title>
    <link href="http://blog.alfss.net//post/2012/10/26/openvpn-plus-autientifikatsiia-po-loghinu-i-paroliu/"/>
    <updated>2012-10-26T22:09:00+04:00</updated>
    <id>http://blog.alfss.net//post/2012/10/26/openvpn-plus-autientifikatsiia-po-loghinu-i-paroliu</id>
    <content type="html"><![CDATA[<p>Мне потребовался доступ к внутренней сети и я решил использовать openvpn для этих целей.
Поскольку LDAP на этот момент еще нету, аутентификация будет на основе файла с паролями в md5.</p>

<h3>Устанавливаем необходимые пакеты</h3>

<p>{% codeblock %}
sudo apt-get install openvpn
{% endcodeblock %}</p>

<!--more-->


<h3>Создание сертификатов</h3>

<p>Идем в /usr/share/doc/openvpn/examples/easy-rsa/2.0/ и выполняем следующие действия.
{% codeblock %}
sh
. ./vars
 ./clean-all
{% endcodeblock %}</p>

<p>Создаем CA сертификат.
{% codeblock %}
./build-ca
{% endcodeblock %}</p>

<ul>
<li>Country Name – 2х буквенный код страны (RU)</li>
<li>State or Province Name (full name) – Государство или название провинции (Russia)</li>
<li>Locality Name (eg, city) – Город (Saint-Peterburg)</li>
<li>Organization Name (eg, company) – Компания(Astrotech SPB)</li>
<li>Organizational Unit Name – Подразделении выдавшие сертификат (IT)</li>
<li>Common Name – имя сервера для которого предназначается сертификат (vpn.spb.astrotech-co.ru)</li>
<li>Email Address – email организации (suppoer@astrotech-co.ru)</li>
</ul>


<p>Создаем X.509 сертификатов для сервера.
{% codeblock %}
./build-key-server server
{% endcodeblock %}</p>

<p>Создайте ключ Диффи Хельман.
{% codeblock %}
openvpn --genkey --secret ta.key
{% endcodeblock %}</p>

<h3>Настройка OpenVPN</h3>

<p>Создадим директории для файлов.
{% codeblock %}</p>

<h1>ключи и сертификаты</h1>

<p>mkdir /etc/openvpn/keys</p>

<h1>скрипт для авторизации</h1>

<p>mkdir /etc/openvpn/auth
{% endcodeblock %}</p>

<p>В директорию /etc/openvpn/keys должны быть скопированы следующие файлы из /usr/share/doc/openvpn/examples/easy-rsa/2.0:</p>

<ul>
<li>ca.crt</li>
<li>dh1024.pem</li>
<li>server.crt</li>
<li>server.key</li>
<li>ta.key</li>
</ul>


<p>Конфиг сервера /etc/openvpn/openvpn.conf.
Опции описывать не буду ибо это просто посмотреть в документации.
{% codeblock %}
script-security 3
tmp-dir /tmp
port 1194
proto tcp
dev tun0
ca /etc/openvpn/keys/ca.crt
cert /etc/openvpn/keys/server.crt
client-cert-not-required
key /etc/openvpn/keys/server.key
dh /etc/openvpn/keys/dh1024.pem
server 10.8.0.0 255.255.255.0
push "route 192.168.0.0 255.255.255.0"
push "dhcp-option DNS 192.168.0.1"
tls-server
tls-auth /etc/openvpn/keys/ta.key 0
tls-timeout 120
auth MD5
cipher BF-CBC
keepalive 10 120
comp-lzo
max-clients 100
user nobody
group nogroup
persist-key
persist-tun
status /var/log/openvpn/openvpn-status.log
log /var/log/openvpn/openvpn.log
verb 4
auth-user-pass-verify /etc/openvpn/auth/auth-static-file.pl via-file
route 10.8.0.0 255.255.255.0
{% endcodeblock %}</p>

<h3>Скрипт авторизации.</h3>

<p>/etc/openvpn/auth/auth-static-file.pl:
{% codeblock lang:perl %}</p>

<h1>!/usr/bin/perl</h1>

<p>#</p>

<h1>$Id$</h1>

<p>#</p>

<h1>Кравчук Сергей, <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#97;&#108;&#x66;&#x73;&#x73;&#46;&#111;&#98;&#x73;&#x64;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#97;&#x6c;&#102;&#x73;&#x73;&#x2e;&#x6f;&#98;&#115;&#100;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a></h1>

<p>#</p>

<p>use strict;
use warnings;
use Digest::MD5  qw(md5 md5_hex md5_base64);
use version; our $VERSION = qv(0.01);</p>

<p>my $password_file = '/etc/openvpn/auth/user_password.txt';
my $ARG = undef;
if ( $ARG = shift @ARGV ) {</p>

<pre><code>if ( !open( UPFILE, "&lt;$ARG" ) ) {
    print "Could not open username/password tmp file: $ARG\n";
    exit 1;
}
</code></pre>

<p>}
else {</p>

<pre><code>print "No username/password file specified on command line\n";
exit 1;
</code></pre>

<p>}</p>

<p>my $username = <UPFILE>;
my $password = <UPFILE>;</p>

<p>if ( !$username || !$password ) {</p>

<pre><code>print "Username/password not found in tmp file: $ARG\n";
exit 1;
</code></pre>

<p>}</p>

<p>chomp $username;
chomp $password;</p>

<p>close(UPFILE);</p>

<p>if ( !open( USER_PASSWORD, "&lt;$password_file" ) ) {</p>

<pre><code>print "Could not open username/password db file: $ARG\n";
exit 1;
</code></pre>

<p>}
foreach my $line (<USER_PASSWORD>) {</p>

<pre><code>chomp($line);
my ( $read_user, $read_password ) = split(/:/, $line);
if ( $read_user eq $username ) {
    my $hex_password = md5_hex $password;
    if ( $hex_password eq $read_password) {
        close(USER_PASSWORD);
        exit 0;
    }
    exit 1;
}
</code></pre>

<p>}</p>

<p>close(USER_PASSWORD);</p>

<p>exit 1;
{% endcodeblock %}</p>

<h3>Конфиг клиента</h3>

<p>Клиент должен иметь следующие файлы:</p>

<ul>
<li>ca.crt</li>
<li>ta.key</li>
<li>vpn_config.ovpn</li>
</ul>


<p>Конфиг клиента:
{% codeblock %}
auth-user-pass
dev tun
proto tcp</p>

<h1>Внешний IP сервера OpenVPN</h1>

<p>remote 55.44.33.33</p>

<h1>Port сервера</h1>

<p>port 1194
client
resolv-retry infinite</p>

<h1>полный путь до сертификата</h1>

<p>ca "/Users/alfss/Documents/vpn/ca.crt"
tls-client</p>

<h1>полный путь до ключа</h1>

<p>tls-auth "/Users/alfss/Documents/vpn/ta.key" 1
auth MD5
cipher BF-CBC
ns-cert-type server
comp-lzo
persist-key
persist-tun
push "dhcp-option DNS 192.168.0.1"
verb 3
{% endcodeblock %}</p>

<h3>Добавление пользователя</h3>

<p>Генерация хэш для пароля:
{% codeblock %}
echo -n 'password' | md5sum
5f4dcc3b5aa765d61d8327deb882cf99
{% endcodeblock %}</p>

<p>файл (/etc/openvpn/auth/user_password.txt)  с пользвателями должен иметь следующий вид:
{% codeblock %}
user1:5f4dcc3b5aa765d61d8327deb882cf99
user2:5f4dcc3b5aa765d61d8327deb882cf99
user3:5f4dcc3b5aa765d61d8327deb882cf99</p>

<p>{% endcodeblock %}</p>

<p>Последний перевод строки обязателен.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Сохранение всей почты в один ящик Postfix + Dovecot]]></title>
    <link href="http://blog.alfss.net//post/2012/09/02/sokhranieniie-vsiei-pochty-v-odin-iashchik-postfix-plus-dovecot/"/>
    <updated>2012-09-02T18:39:00+04:00</updated>
    <id>http://blog.alfss.net//post/2012/09/02/sokhranieniie-vsiei-pochty-v-odin-iashchik-postfix-plus-dovecot</id>
    <content type="html"><![CDATA[<p>Мне потребовалось реализовать сохранение всей исходящей и входящей почты в один ящик на тестовом сервер.
Как SMTP  я выбрал Postfix за его простоту и Dovecot как imap сервер и сервер доставки.</p>

<p>Описывать как все ставить с нуля я не буду, опишу лишь основные моменты.</p>

<h3>Настройка Postfix</h3>

<!--more-->


<p>В master.cf описываем наш новый сервис:</p>

<p>{% codeblock lang:bash %}
dovecot  unix  -       n       n       -       -       pipe
   flags=DRhu user=webuser argv=/usr/lib/dovecot/deliver -d webuser
{% endcodeblock %}</p>

<p>Вся почта будет складываться в каталог пользователя webuser.</p>

<p>Устанавливаем службу dovecot(описанную выше) как дефолтную для доставки.</p>

<p>main.cf:
{% codeblock lang:bash %}
default_transport = dovecot
{% endcodeblock %}</p>

<h3>Теперь переходим к настройке dovecot.</h3>

<p>Описываем как и где смотреть пользователей (я выбрал хранение в файле).</p>

<p>{% codeblock lang:bash %}
passdb {
  driver = passwd-file
  args = scheme=plain-md5 username_format=%n /etc/dovecot/users
}</p>

<p>userdb {
  driver = passwd-file
  args = username_format=%n /etc/dovecot/users
}
{% endcodeblock %}</p>

<p>Будем хранить почту в формате Maildir. Указываем директорию и формат хранения.</p>

<p>{% codeblock lang:bash %}
mail_location = maildir:/srv/mail/%n
{% endcodeblock %}
<em>/srv/mail пренадлежит webuser(uid 2000:gid 2000)</em></p>

<p>Заключительный шаг. Описываем нашего пользователя (webuser) в файле /etc/dovecot/users</p>

<p>{% codeblock lang:bash %}
webuser:{plain}jagsjhdgajhsd:2000:2000::/home/webuser
{% endcodeblock %}</p>

<ul>
<li>webuser - имя пользователя</li>
<li>{plain}jagsjhdgajhsd - наш пароль в открытом виде</li>
<li>цыфры это uid и gid.</li>
</ul>

]]></content>
  </entry>
  
</feed>
